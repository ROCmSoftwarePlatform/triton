\ExplSyntaxOn
\NewExpandableDocumentCommand{\bitwiseXor}{mm}
 {
  \recuenco_bitwise_xor:nn { #1 } { #2 }
 }

\cs_new:Nn \recuenco_bitwise_xor:nn
 {
  \int_from_bin:e
   {
    \__recuenco_bitwise_xor:ee { \int_to_bin:n { #1 } } { \int_to_bin:n { #2 } }
   }
 }
\cs_generate_variant:Nn \int_from_bin:n { e }

\cs_new:Nn \__recuenco_bitwise_xor:nn
 {
  \__recuenco_bitwise_xor_binary:ee
   {
    \prg_replicate:nn
     {
      \int_max:nn { \tl_count:n { #1 } } { \tl_count:n { #2 } } - \tl_count:n { #1 }
     }
     { 0 }
     #1
   }
   {
    \prg_replicate:nn
     {
      \int_max:nn { \tl_count:n { #1 } } { \tl_count:n { #2 } } - \tl_count:n { #2 }
     }
     { 0 }
     #2
   }
 }
\cs_generate_variant:Nn \__recuenco_bitwise_xor:nn { ee }

\cs_new:Nn \__recuenco_bitwise_xor_binary:nn
 {
  \__recuenco_bitwise_xor_binary:w #1;#2;
 }
\cs_generate_variant:Nn \__recuenco_bitwise_xor_binary:nn { ee }

\cs_new:Npn \__recuenco_bitwise_xor_binary:w #1#2;#3#4;
 {
  \int_abs:n { #1-#3 }
  \tl_if_empty:nF { #2 } { \__recuenco_bitwise_xor_binary:w #2;#4; }
 }

\ExplSyntaxOff

\newcommand{\drawTensorLayoutGlobalMem}{
  %%
  %% Draw tensor layout in global memory without any swizzling
  %%
  %% TL: pre defined top-left coordinates of the tensor in global memory
  %% \elemH: The height of each element
  %% \bsize: The width of each byte
  %% \Colors: a pre defined array of 16 colors
  %%
  %% The following arguments are also expected to be pre defined
  %% #1: M
  %% #2: K
  %% #3: vecInBytes: number of bytes in a group

  \pgfmathsetmacro{\groups}{64/\mfmaNonKDim}
  \pgfmathsetmacro{\maxGpId}{\groups-1}
  \pgfmathsetmacro{\maxRowId}{\mfmaNonKDim-1}
  \pgfmathsetmacro{\elemsPerVec}{\vec}

  \pgfmathsetmacro{\vecInK}{\K/\elemsPerVec}
  \pgfmathsetmacro{\maxKVecId}{\vecInK-1}

  \foreach \gp in {0,...,\maxKVecId}{
    \pgfmathsetmacro{\gpCol}{int(mod(\gp, 16))}
    \pgfmathsetmacro{\vecColor}{\Colors[\gpCol]}
    \pgfmathsetmacro{\kStart}{int(\gp*\elemsPerVec)}
    \pgfmathsetmacro{\kEnd}{int(\kStart+\elemsPerVec-1)}
    \foreach \row in {0,...,\maxRowId}{
      \coordinate (vec TL) at ($(TL)+(\gp*\vecInBytes*\bsize, -\row*\elemH)$);
      \draw [ultra thin, fill=\vecColor] (vec TL) rectangle ++(\vecInBytes*\bsize, -\elemH)
      node [pos=.5, scale=.6*\bankLabelScale*\scale, white] {m\row,k\kStart:\kEnd};
    }
  }
  %%  M and K dim
  \def\gap{3}
  \pgfmathsetmacro{\drawM}{\mfmaNonKDim*\elemH+\gap*\elemH}
  \pgfmathsetmacro{\drawK}{\vecInK*\vecInBytes*\bsize}
  \draw [ultra thick] (TL) rectangle ++(\drawK, -\drawM);
  %\node [scale=\scale, rotate=90, above] at ($(TL)+(0, -.5*\drawM)$) {BLOCK\_M=\M};
  \node [scale=\scale, above] at ($(TL)+(.5*\drawK, 0)$) {Tile:\M$\times$\K$\times$\dtype};
  \node [scale=\scale, rotate=90] at ($(TL)+(0.5*\K*\bytesPerElem*\bsize, -\drawM+.5*\gap*\elemH)$) {$\ldots$};
  %\node [scale=\scale, below] at ($(TL)+(0.5*\drawK, -\drawM)$) {Tile:\M$\times$\K$\times$\dtype};
}


\newcommand{\drawLDSDiagram}[1]{
  %%
  %% Draw the diagram of LDS without any data
  %%
  %% Pre-defined variables
  %% TL: top-left coordinates of first elements in LDSaccess
  %% bsize: size of a byte
  %% mfmaNonKDim
  %% K
  %% bytesPerElem
  %%
  %% #1: number of banks

  \pgfmathsetmacro{\banks}{#1}
  \pgfmathsetmacro{\maxBankId}{\banks-1}
  \pgfmathsetmacro{\tensorHeight}{\mfmaNonKDim*\K*\bytesPerElem/4/\banks*\elemH}
  \def\gapT{4}
  \def\gapB{2}
  \pgfmathsetmacro{\LDSHeight}{\tensorHeight+\gapT*\elemH+\gapB*\elemH}
  \coordinate (LDS TL) at ($(TL)+(0, \gapT*\elemH)$);
  \foreach \bank in {0,...,\maxBankId}{
    \coordinate (bank TL) at ($(LDS TL)+(\bank*4*\bsize, 0)$);
    \draw [ultra thick] (bank TL) rectangle ++(4*\bsize, -\LDSHeight)
    node [scale=.6*\bankLabelScale*\scale, pos=0, below right, align=center] {bank\\\bank};
    \node [scale=0.8*\bankLabelScale*\scale, rotate=90] at ($(TL)+(2*\bsize+\bank*4*\bsize, -\tensorHeight-0.5*\gapB*\elemH)$) {$\ldots$};
  }
  \node [scale=\scale, above] at ($(TL)+(0.5*\banks*4*\bsize, 4*\elemH)$) {LDS \banks\ banks};
}

\newcommand{\drawHighlightedAccess}[3]{
  %% Highlight the vectors if \tid < \threshold
  %%
  %% Predefined variables
  %% vec TL: top-left of the current vector
  %% elemH, bsize, vecInBytes, bankLabelScale
  %%
  %% #1: tid
  %% #2: threshold
  %% #3: label in vector

  \pgfmathsetmacro{\tid}{#1}
  \pgfmathsetmacro{\threshold}{#2}
  \def\bWidth{0.02}

  \ifthenelse{\tid < \threshold}{
    \ifthenelse{\vecInBits=128}{\def\ratio{0.5}}{\def\ratio{1}}
    \draw [thick, draw=white, fill=\vecColor] ($(vec TL)+(\bWidth, -\bWidth)$) rectangle ++(\vecInBytes*\bsize-2*\bWidth, -\elemH+2*\bWidth);
    \ifthenelse{\vecInBits=128}{
      \node [scale=.6*\bankLabelScale*\scale, white] at ($(vec TL)+(\ratio*\vecInBytes*\bsize, -0.5*\elemH)$) {#3};
    }{
      \node [scale=.6*\bankLabelScale*\scale, white, left] at ($(vec TL)+(\ratio*\vecInBytes*\bsize, -0.5*\elemH)$) {#3};
    }
    \node [scale=.5*\bankLabelScale*\scale, right] at ($(vec TL)+(0, -0.5*\elemH)$) {\textbf{t\tid}};
  }{}
}

\newcommand{\drawCoalescedGRAccess}[3]{
  %% Highlight the vectors in original tile if \tid < \threshold
  %%
  %% Predefined variables
  %% tile TL: top-left of the original tile
  %% gp: vector group id along K dim
  %% row: row index
  %% elemH, bsize, vecInBytes, bankLabelScale
  %%
  %% #1: tid
  %% #2: threshold
  %% #3: label in vector

  \pgfmathsetmacro{\tid}{#1}
  \pgfmathsetmacro{\threshold}{#2}
  \def\bWidth{0.02}

  \ifthenelse{\tid < \threshold}{
    \ifthenelse{\vecInBits=128}{\def\ratio{0.5}}{\def\ratio{1}}
    \coordinate (tile vec TL) at ($(tile TL)+(\gp*\vecInBytes*\bsize, -\row*\elemH)$);
    \draw [thick, draw=white, fill=\vecColor] ($(tile vec TL)+(\bWidth, -\bWidth)$) rectangle ++(\vecInBytes*\bsize-2*\bWidth, -\elemH+2*\bWidth);
    \ifthenelse{\vecInBits=128}{
      \node [scale=.6*\bankLabelScale*\scale, white] at ($(tile vec TL)+(\ratio*\vecInBytes*\bsize, -0.5*\elemH)$) {#3};
    }{
      \node [scale=.6*\bankLabelScale*\scale, white, left] at ($(tile vec TL)+(\ratio*\vecInBytes*\bsize, -0.5*\elemH)$) {#3};
    }
    \node [scale=.5*\bankLabelScale*\scale, right] at ($(tile vec TL)+(0, -0.5*\elemH)$) {\textbf{t\tid}};
  }{}
}

\newcommand{\drawLDSLayoutAndAccess}[3]{
  %%
  %% Draw tensor layout in LDS with swizzling
  %%
  %% TL: pre defined top-left coordinates of the tensor in global memory
  %% \elem: per defined variable
  %% \Colors: a pre defined array of 16 colors
  %%
  %% The following three arguments are expected to be pre defined
  %% #1: M
  %% #2: K
  %% #3: vec: number of elements in a group
  %%
  %% #1: hasSwizzle, 0 means no swizzling and no padding,
  %%                 1 means optimal swizzling
  %%                 2 means padding
  %% #2: access mode, 0 means draw nothing, 1 means ds_read, 2 means ds_write
  %% #3: number of banks
  %% For ds_write access, the following variables are assumed to be pre defined
  %% \sizePerThreadK
  %% \sizePerThreadM
  %% \threadsPerWarpK

  \pgfmathsetmacro{\hasSwizzle}{#1}
  \pgfmathsetmacro{\accessMode}{#2}
  \pgfmathsetmacro{\numVecK}{\K/\vec}
  \pgfmathsetmacro{\banks}{#3}

  \drawLDSDiagram{#3}

  \pgfmathsetmacro{\LDSK}{int(\banks*4/\bytesPerElem)}
  \pgfmathsetmacro{\numLDSVec}{\LDSK/\vec}
  \pgfmathsetmacro{\maxKVecId}{\K/\vec-1}

  %% Parameters for ds_read
  % \vecInBytes: access width in bytes
  % \vecInBits: access width in bits (ds_read_b64 or ds_read_b128)
  % \numThreadsSameCycle: number of threads that will access LDS at the same cycle (8, 16, or 32)
  \pgfmathsetmacro{\vecInBits}{int(\vecInBytes*8)}
  \pgfmathsetmacro{\numThreadsSameCycle}{int(\banks*4/\vecInBytes)}
  \pgfmathsetmacro{\maxTid}{int(\numThreadsSameCycle-1)}

  %% Parameters for swizzling
  %% perPhase = ceil(LDSK / K)
  %% The number of the rows of the tensor that can share the same swizzling pattern
  \pgfmathsetmacro{\perPhase}{ceil(\LDSK/\K)}
  %% maxPhase: the total number of different swizzling patterns
  \ifthenelse{\hasSwizzle=0}{
    %% When swizzling is disabled
    \pgfmathsetmacro{\maxPhase}{1}
  }{
    %% When vec is small enough, we want 16/perPhase different swizzling patterns
    %% When vec is large, we can only have 64 / \vec different swizzling pattern at most
    \pgfmathsetmacro{\maxPhase}{min(min(\mfmaNonKDim,\numThreadsSameCycle)/\perPhase,\banks*4/\bytesPerElem/\vec)}
  }

  %% Draw the vectors according to the swizzling pattern
  \foreach \gp in {0,...,\maxKVecId}{
    \pgfmathsetmacro{\gpCol}{int(mod(\gp, 16))}
    \pgfmathsetmacro{\vecColor}{\Colors[\gpCol]}
    \pgfmathsetmacro{\kStart}{int(\gp*\elemsPerVec)}
    \pgfmathsetmacro{\kEnd}{int(\kStart+\elemsPerVec-1)}
    \foreach \row in {0,...,\maxRowId}{
      %% Compute some info of the current vec
      % global offset in unit of vec
      \pgfmathsetmacro{\offVec}{\row*\K/\vec+\gp}
      % which row of LDS
      \pgfmathsetmacro{\LDSRow}{int(\offVec/\numLDSVec)}
      % offset in the current LDS row in the unit of vec
      \pgfmathsetmacro{\LDSVecRaw}{int(mod(\offVec,\numLDSVec))}
      \pgfmathsetmacro{\phaseRaw}{int(\row/\perPhase)}
      \pgfmathsetmacro{\phase}{int(mod(\phaseRaw, \maxPhase))}
      \pgfmathsetmacro{\LDSVec}{\bitwiseXor{\LDSVecRaw}{\phase}}

      \coordinate (vec TL) at ($(TL)+(\LDSVec*\vecInBytes*\bsize, -\LDSRow*\elemH)$);
      \draw [ultra thin, fill=\vecColor] (vec TL) rectangle ++(\vecInBytes*\bsize, -\elemH)
      node [pos=.5, scale=.6*\bankLabelScale*\scale, white] {m\row,k\kStart:\kEnd};

      %% draw phase of each LDS row
      \pgfmathsetmacro{\lastVecId}{\numLDSVec-1}
      \ifthenelse{\LDSVec=\lastVecId}{
        \draw [ultra thin] ($(vec TL)+(\vec*\bytesPerElem*\bsize, -.5*\bsize)$) -- ++(\elemH, 0)
        node [scale=0.6*\bankLabelScale*\scale, right] {\phase};
      }{}

      %% For ds_read/write access patterns, we first decide the thread id that owns
      %% the current vector. And then we decide if the current vector is accessed
      %% at the first cycle according to thread id and access width
      %% Draw ds_read
      \ifthenelse{\accessMode=1}{
        % compute thread id for current vec
        \pgfmathsetmacro{\tid}{int(\gp*\mfmaNonKDim+\row)}
        % draw ds_read instruction name
        \ifthenelse{\tid=0}{
          \node [scale=\scale, above right] at ($(TL)+(0, \gapT*\elemH)$)
          {ds\_read\_b\vecInBits\ (t0$\sim$t\maxTid)};}{}
      }{} %% End draw ds_read

      %% Draw ds_write
      \ifthenelse{\accessMode=2}{
        % compute thread id for current vec
        % Here we assume the following global load pattern:
        % - global/buffer_load_dwordx4, i.e. sizePerThread[1] = 128-bit
        % - CTA coverage will always cover all elements along the K dim first, i.e.
        %   sizePerThread[1]*threadsPerWarp[1] == K or
        %   (sizePerThread[1]*threadsPerWarp[1] < K and threadsPerWarp[0] == 1)
        \pgfmathsetmacro{\offBytes}{int(\row*\K*\bytesPerElem+\gp*\vecInBytes)}
        \pgfmathsetmacro{\tidRaw}{int(\offBytes/16)}
        \pgfmathsetmacro{\remTid}{int(mod(\offBytes,16))}
        \drawCoalescedGRAccess{\tidRaw}{\numThreadsSameCycle}{m\row,k\kStart:\kEnd}
        \ifthenelse{\remTid>0}{\pgfmathsetmacro{\tid}{int(\tidRaw+32)}}{\pgfmathsetmacro{\tid}{\tidRaw}}
        % draw ds_write instruction name
        \ifthenelse{\tid=0}{
          \node [scale=\scale, above right] at ($(TL)+(0, \gapT*\elemH)$)
          {ds\_write\_b\vecInBits\ (t0$\sim$t\maxTid)};}{}
      }{}
      % highlight vector of the threads that will access LDS at the same cycle
      \drawHighlightedAccess{\tid}{\numThreadsSameCycle}{m\row,k\kStart:\kEnd}
    }
  }
  \node [scale=0.6*\bankLabelScale*\scale, above right] at($(TL)+(\banks*4*\bsize, 0)$) {phase};
  

  %% Start old code
  \ifthenelse{\accessMode = 2}{
    %% \accessMode == 2, draw 8 rows
    \pgfmathsetmacro{\maxVecId}{8*\numVecK-1}
    \pgfmathsetmacro{\drawM}{8*\K/\LDSK+4}
  }{
    %% \accessMode == 0 or 1, draw 16 rows
    \pgfmathsetmacro{\maxVecId}{16*\numVecK-1}
    \pgfmathsetmacro{\drawM}{16*\K/\LDSK+4}
  }
  \pgfmathsetmacro{\swizzleK}{max(\LDSK, \K)}
  \pgfmathsetmacro{\numVecSwizzleK}{\swizzleK/\vec}
  \pgfmathsetmacro{\LDSM}{int(\M/\LDSK*\K)}
  %% Draw detailed vec view of LDS
  \foreach \vecId in {0,...,\maxVecId}{
    \pgfmathsetmacro{\vecCoordM}{int(\vecId/\numVecK)}
    \pgfmathsetmacro{\vecCoordK}{int(mod(\vecId,\numVecK))}
    \pgfmathsetmacro{\rawPhase}{floor(\vecId/\numVecSwizzleK)}
    %% vec color
    \pgfmathsetmacro{\colorIdxK}{int(mod(\vecCoordK,16))}
    \pgfmathsetmacro{\colorIdxM}{mod(\vecCoordM,16)}
    \pgfmathsetmacro{\ratio}{100-floor(\vecCoordK/16)*40}
    \pgfmathsetmacro{\vecColor}{\Colors[\colorIdxK]}

    %% old vec coordinates
    \coordinate (vec TL) at ($(TL)+(\vecCoordK*\vec*\elem, -\vecCoordM*\elem)$);

    %% new vec coordinates in LDS by swizzling
    %% The following two conditions correspond to the relation between \LDSK and \K
    \ifthenelse{\LDSK < \K}{
      \pgfmathsetmacro{\vecLDSM}{\vecCoordM*\K/\LDSK+floor(\vecCoordK*\vec/\LDSK)}
      \pgfmathsetmacro{\vecLDSK}{int(mod(\vecCoordK, \LDSK/\vec))}
    }{
      \pgfmathsetmacro{\vecLDSM}{floor(\vecCoordM/\perPhase)}
      \pgfmathsetmacro{\vecLDSK}{int(\vecCoordK+mod(\vecCoordM,\perPhase)*\numVecK)}
    }
    %%
    \pgfmathsetmacro{\phase}{int(mod(\rawPhase, \maxPhase))}
    %% Compute the swizzled col id
    \pgfmathsetmacro{\vecLDSKSwizzled}{\bitwiseXor{\vecLDSK}{\phase}}

    %% new vec coordinates in LDS by padding
    \pgfmathsetmacro{\numPads}{floor(\vecId/\numLDSVec)}
    \pgfmathsetmacro{\bankId}{\vec/2*\vecId+\numPads}
    \pgfmathsetmacro{\vecPadM}{int(\bankId/32)}
    \pgfmathsetmacro{\vecPadK}{int(mod(\bankId,32))}

    \ifthenelse{\hasSwizzle = 2}{
      %% vec coordinates by padding
      \coordinate (new vec TL) at ($(TL)+(\vecPadK*2*\elem, -\vecPadM*\elem)$);
      \pgfmathsetmacro{\tailBankId}{int(\vecPadK+\vec/2-1)}
    }{
      %% vec coordinates by swizzling
      \coordinate (new vec TL) at ($(TL)+(\vecLDSKSwizzled*\vec*\elem, -\vecLDSM*\elem)$);
      \pgfmathsetmacro{\tailBankId}{0}
    }

    %\ifthenelse{\hasSwizzle = 2 \AND \tailBankId > 31}{
    %  \pgfmathsetmacro{\nextBanks}{\tailBankId-31}
    %  \pgfmathsetmacro{\leftBanks}{\vec/2 - \nextBanks}
    %  \draw [ultra thin, fill=\vecColor!\ratio!white] (new vec TL) rectangle ++(\leftBanks*2*\elem, -\elem)
    %  node [pos=.5, scale=.6*\scale, white] {m\vecCoordM};
    %  \draw [ultra thin, fill=\vecColor!\ratio!white] ($(TL)+(0, -\vecPadM*\elem-\elem)$)
    %  rectangle ++(\nextBanks*2*\elem, -\elem) node [pos=.5, scale=.6*\scale, white] {m\vecCoordM};
    %}{
    %  \draw [ultra thin, fill=\vecColor!\ratio!white] (new vec TL) rectangle ++(\vec*\elem, -\elem)
    %  node [pos=.5, scale=.6*\scale, white] {m\vecCoordM};
    %}
  }
}
